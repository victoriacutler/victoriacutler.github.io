[
  {
    "objectID": "posts/suitable-habitats/index.html",
    "href": "posts/suitable-habitats/index.html",
    "title": "Finding Suitable Locations for Marine Aquaculture",
    "section": "",
    "text": "Marine aquaculture holds tremendous promise in addressing the global demand for sustainable protein sources, surpassing conventional land-based meat production. Recent research conducted by Gentry et al. has shed light on the vast potential of marine aquaculture worldwide, considering various crucial factors like ship traffic, dissolved oxygen, and bottom depth. (Gentry et al. 2017)"
  },
  {
    "objectID": "posts/suitable-habitats/index.html#finding-suitable-locations-for-aquaculture",
    "href": "posts/suitable-habitats/index.html#finding-suitable-locations-for-aquaculture",
    "title": "Finding Suitable Locations for Marine Aquaculture",
    "section": "Finding Suitable Locations for Aquaculture",
    "text": "Finding Suitable Locations for Aquaculture\nIn this post, we embark on a journey to identify the most suitable Exclusive Economic Zones (EEZ) along the West Coast of the US for cultivating several oyster species. Our objective is to pinpoint areas where the ideal conditions for oyster growth, such as sea surface temperature and depth, converge, setting the stage for thriving oyster aquaculture ventures."
  },
  {
    "objectID": "posts/suitable-habitats/index.html#metadata",
    "href": "posts/suitable-habitats/index.html#metadata",
    "title": "Finding Suitable Locations for Marine Aquaculture",
    "section": "Metadata",
    "text": "Metadata\n\nSea Surface Temperature\nWe will use average annual sea surface temperature (SST) from the years 2008 to 2012 to characterize the average sea surface temperature within the region. The data we are working with was originally generated from NOAA’s 5km Daily Global Satellite Sea Surface Temperature Anomaly v3.1.\n\n\nBathymetry\nTo characterize the depth of the ocean we will use the General Bathymetric Chart of the Oceans (GEBCO).1\n\n\nExclusive Economic Zones\nWe will be designating maritime boundaries using Exclusive Economic Zones off of the west coast of US from Marineregions.org."
  },
  {
    "objectID": "posts/suitable-habitats/index.html#the-code",
    "href": "posts/suitable-habitats/index.html#the-code",
    "title": "Finding Suitable Locations for Marine Aquaculture",
    "section": "The Code",
    "text": "The Code\n\nLoading the Libraries\n\n# loading necessary libraries\nlibrary(here)\nlibrary(sf)\nlibrary(terra)\nlibrary(raster)\nlibrary(dplyr)\nlibrary(rpart)\nlibrary(rpart.plot)\nlibrary(tmap)\n\n\n\nLoading and Cleaning Up the Data\nHere I read in all the spatial data: west coast zone data, yearly sea surface temperature data, and approximate depth data. I then clean the data by (1) checking and aligning coordinate reference systems, map projections, spatial extent, and spatial resolutions (so that our data are correctly aligned in space) and (2) converting data types and units (for dataset compatibility and ease of future calculations).\nNotes on Methodology: You’ll see that I use the nearest neighbors approach to resample the depth data to match the resolution of the sea surface temperature data, which is of lower resolution. Downscaling like this is a common practice with geospatial datasets since the nearest neighbors approach preserves the original data by assigning the closest pixel in the higher resolution dataset (in this case the closest depth data point) to the newly created lower resolution pixel. I chose this method primarily due to its computational efficiency. Since depth data is continuous, for more accurate analysis something like bilinear or cubic interpolation may be better here.\n\n# set working directory to here\nsetwd(here())\n\n# read in the shapefile of the maritime boundaries of the west coast region\nwc_regions <- st_read(here(\"posts\", \"suitable-habitats\", \"data\", \"wc_regions_clean.shp\"))\n\nReading layer `wc_regions_clean' from data source \n  `/Users/victoriacutler/Documents/MEDS/victoriacutler.github.io/posts/suitable-habitats/data/wc_regions_clean.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -129.1635 ymin: 30.542 xmax: -117.097 ymax: 49.00031\nGeodetic CRS:  WGS 84\n\n# read in the yearly sea surface temperature (SST) raster layers\naverage_annual_sst_2008 <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"average_annual_sst_2008.tif\"))\naverage_annual_sst_2009 <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"average_annual_sst_2009.tif\"))\naverage_annual_sst_2010 <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"average_annual_sst_2010.tif\"))\naverage_annual_sst_2011 <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"average_annual_sst_2011.tif\"))\naverage_annual_sst_2012 <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"average_annual_sst_2012.tif\"))\n\n# combine rasters into a stack\navg_annual_sst_stack <- stack(c(average_annual_sst_2008, average_annual_sst_2009, average_annual_sst_2010, average_annual_sst_2011, average_annual_sst_2012))\n\n# read in the bathymetry (aka depth) raster\ndepth <- rast(here(\"posts\", \"suitable-habitats\", \"data\", \"depth.tif\"))\n\n# check the coordinate reference systems (CRSs)\ncat(crs(wc_regions))\n\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\ncat(as.character(crs(avg_annual_sst_stack)))\n\n+proj=longlat +ellps=WGS84 +no_defs\n\ncat(crs(depth))\n\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n  # converting the STT stack back to a SpatRaster to use terra functions, like to change the crs\navg_annual_sst_stack <- rast(avg_annual_sst_stack)\n\n  # converting the STT stack SpatRast to the matching crs\ncrs(avg_annual_sst_stack) = \"EPSG:4326\"\n\n# find the mean SST then convert to Celcius\naverage_sst_degC <- mean(avg_annual_sst_stack, na.rm = TRUE) - 273.15\n\n# crop the depth raster to match the extent of the SST raster\ndepth_newextent <- crop(depth, average_sst_degC) # you can see that the extents are now the same\n\n# resample the depth raster such that the resolution is the same as the resolution in the SST raster\ndepth_newres <- resample(x = depth_newextent, y = average_sst_degC, method = \"near\")\n\n# checking that the dimensions, resolutions, extent, and crs match\naverage_sst_degC\n\nclass       : SpatRaster \ndimensions  : 480, 408, 1  (nrow, ncol, nlyr)\nresolution  : 0.04166185, 0.04165702  (x, y)\nextent      : -131.9848, -114.9867, 29.99305, 49.98842  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        :   mean \nmin value   :  4.980 \nmax value   : 32.895 \n\ndepth_newres\n\nclass       : SpatRaster \ndimensions  : 480, 408, 1  (nrow, ncol, nlyr)\nresolution  : 0.04166185, 0.04165702  (x, y)\nextent      : -131.9848, -114.9867, 29.99305, 49.98842  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : depth \nmin value   : -5468 \nmax value   :  4218 \n\n  # doing this by checking to see that the two rasters can be stacked\nstack_test <- rast(c(average_sst_degC, depth_newres))\nstack_test # stackable\n\nclass       : SpatRaster \ndimensions  : 480, 408, 2  (nrow, ncol, nlyr)\nresolution  : 0.04166185, 0.04165702  (x, y)\nextent      : -131.9848, -114.9867, 29.99305, 49.98842  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \n\n\n\n\nUsing Reclassification Matrices to Assess Oyster Ecosystem Suitability\nIn this process, I conduct a reclassification of both the sea surface temperature raster and depth raster. Areas with suitable depth or temperature for oyster aquaculture are assigned a value of ‘1’, while unsuitable areas are marked as ‘NA’. By subsequently employing the lapply() function, I perform a multiplication operation on the reclassified rasters. The outcome is a final raster presenting a clear distinction between ‘1s’ indicating suitable habitat and ‘NAs’ representing areas unsuitable for oyster cultivation, providing a comprehensive depiction of overall suitability.\n\n# reclassifying the SST raster for oyster suitability (11-30°C)\n\n  # first creating a reclassification matrix\nrcl_sst <- matrix(c(-Inf, 11, NA,\n                    11, 30, 1,\n                 30, Inf, NA), ncol = 3, byrow = TRUE)\n  # then reclassify the matrix\nsst_suitable <- classify(average_sst_degC, rcl = rcl_sst)\n\n# reclassifying the depth raster for oyster suitability (-70-0)\n\n  # first creating a reclassification matrix\nrcl_depth <- matrix(c(-Inf, -70, NA,\n                    -70, 0, 1,\n                 0, Inf, NA), ncol = 3, byrow = TRUE)\n  # then reclassify the matrix\ndepth_suitable <- classify(depth_newres, rcl = rcl_depth)\n\n# finding locations where depth and sst are suitable for oysters\n  # making a raster multiplication function\nmult_fun = function(rast1, rast2){\n  rast1 * rast2\n}\n\n  # creating the raster that has NAs where both are not suitable, and 1s where depth and sst are suitable\ndepth_and_stt_suitable <- lapp(c(depth_suitable, sst_suitable), fun = mult_fun)\n\n\n\nScaling to Zones of Interest (Ecological Economic Zones)\n\n# data exploration - are these rasters of the same extent/crs etc? yes!\nwc_regions\n\nSimple feature collection with 5 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -129.1635 ymin: 30.542 xmax: -117.097 ymax: 49.00031\nGeodetic CRS:  WGS 84\n                  rgn rgn_key      area_m2 rgn_id  area_km2\n1              Oregon      OR 179994061293      1 179994.06\n2 Northern California    CA-N 164378809215      2 164378.81\n3  Central California    CA-C 202738329147      3 202738.33\n4 Southern California    CA-S 206860777840      4 206860.78\n5          Washington      WA  66898309678      5  66898.31\n                        geometry\n1 MULTIPOLYGON (((-123.4318 4...\n2 MULTIPOLYGON (((-124.2102 4...\n3 MULTIPOLYGON (((-122.9928 3...\n4 MULTIPOLYGON (((-120.6505 3...\n5 MULTIPOLYGON (((-122.7675 4...\n\ndepth_and_stt_suitable\n\nclass       : SpatRaster \ndimensions  : 480, 408, 1  (nrow, ncol, nlyr)\nresolution  : 0.04166185, 0.04165702  (x, y)\nextent      : -131.9848, -114.9867, 29.99305, 49.98842  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : lyr1 \nmin value   :    1 \nmax value   :    1 \n\n  # first, make wc_regions into a raster\nwc_regions_simp <- wc_regions |> \n  select(\"rgn\")\n\nwc_regions_rast <- rasterize(x = wc_regions_simp, y = depth_and_stt_suitable, field = \"rgn\")\n\n# finding the suitable cells within each region\n  # first mask the region raster with the suitable cells (since not suitable cells are NA, our region raster will only have values where suitable)\nwc_regions_mask <- mask(wc_regions_rast, depth_and_stt_suitable)\n\n  # lastly, displaying our suitable cells within each region that are suitable\ntm_shape(wc_regions_mask) +\n  tm_raster()\n\nSome legend labels were too wide. These labels have been resized to 0.65. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n\n\n\n\n# finding the area of the suitable grid cells of each region\nsuitable_area_byregion <- zonal(cellSize(wc_regions_mask, unit=\"m\"), wc_regions_mask, fun = \"sum\") |> \n  mutate(area = area / (1000^2)) |> \n  rename(suitable_area_km2 = area)\nsuitable_area_byregion \n\n                  rgn suitable_area_km2\n1  Central California         4923.1537\n2 Northern California          438.1535\n3              Oregon         1533.0949\n4 Southern California         4096.5404\n5          Washington         3224.7377\n\n# finding the area of the grid cells for each region (even though we have this already reported in the original datafile, we're using the same method we used to calculate our suitable area to make sure percentages are more likely proportional, since there are slight differences in this area approximation method). \ntotal_area_byregion <- zonal(cellSize(wc_regions_rast, unit=\"m\"), wc_regions_rast, fun = \"sum\") |> \n  mutate(area = area / (1000^2)) |> \n  rename(total_area_km2 = area)\ntotal_area_byregion \n\n                  rgn total_area_km2\n1  Central California      202779.85\n2 Northern California      163715.00\n3              Oregon      179866.42\n4 Southern California      206535.86\n5          Washington       67813.69\n\n# find the percent of suitable area per area per region\npercent_area_df <- inner_join(total_area_byregion, suitable_area_byregion, by = \"rgn\") |> mutate(percent_suitable = (suitable_area_km2/total_area_km2) * 100)\n\n# source code: https://stackoverflow.com/questions/68979884/how-to-loop-through-a-dataframe-and-get-value-of-corresponding-column\nfor(i in 1:dim(percent_area_df)[1]) {\n  writeLines((paste0(percent_area_df$rgn[i], \" has an area suitable for oysters of \" , round(percent_area_df$suitable_area_km2[i], 2), \"km2 which amounts to an area that is \", round(percent_area_df$percent_suitable[i],2), \"% suitable for oysters.\",\"\\n\")))\n}\n\nCentral California has an area suitable for oysters of 4923.15km2 which amounts to an area that is 2.43% suitable for oysters.\n\nNorthern California has an area suitable for oysters of 438.15km2 which amounts to an area that is 0.27% suitable for oysters.\n\nOregon has an area suitable for oysters of 1533.09km2 which amounts to an area that is 0.85% suitable for oysters.\n\nSouthern California has an area suitable for oysters of 4096.54km2 which amounts to an area that is 1.98% suitable for oysters.\n\nWashington has an area suitable for oysters of 3224.74km2 which amounts to an area that is 4.76% suitable for oysters.\n\n  # test: look at percentages using the given areas to see if theyre similar:\n#percent_area_df_originalareas <- merge(wc_regions, suitable_area_byregion, by = \"rgn\") |> mutate(percent_suitable = (suitable_area_km2/area_km2) * 100)\n\n\n\nVisualizing Suitable Ecological Economic Zones\n\n# first joining the the area_df back to the region sf object for plotting\nregion_stats_join <- merge(wc_regions, percent_area_df)\n\n# switching to tmap view mode to add a built in basemap\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\n# total suitable area by region\n  # create legend title\n#legend_title_area = expression(\"Suitable Area for Oysters (km\"^2*\")\")\nlegend_title_area = expression(\"Suitable Area for Oysters (km^2)\")\narea_suitable_map <- tm_shape(region_stats_join) +\n  tm_fill(col = \"suitable_area_km2\",\n          title = legend_title_area,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders() +\n  tm_legend(legend.outside = TRUE) +\n  #tm_layout(main.title = \"West Coast Regions Suitable for Oysters\",\n            #main.title.size = 1)  +\n  tm_text(\"rgn\", size = 0.3) +\n  tm_basemap(server = \"OpenTopoMap\")\n\n# percent suitable area by region\npercent_suitable_map <- tm_shape(region_stats_join) +\n  tm_fill(col = \"percent_suitable\",\n          title = \"Percent of Region Suitable for Oysters\",\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders() +\n  tm_legend(legend.outside = TRUE) +\n # tm_layout(main.title = \"Percent of West Coast Region Suitable for Oysters\",\n           # main.title.size = 1) +\n  tm_text(\"rgn\", size = 0.3) +\n  tm_basemap(server = \"OpenTopoMap\")\n\ntmap_arrange(area_suitable_map, percent_suitable_map)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Function to Broaden this Workflow\nThis sort of analysis can be applicable for many different applications. Not only can this analysis be used to assess aquaculture suitability for other species, not just the oyster, but it can also be used to assess critical habitat needs for any key marine life that depends on certain sea surface temperature and ocean depth.\nHere I turn my analysis into a function that takes in the marine species of interest, habitat temperature and depth ranges and returns maps of total suitable area and percent suitable area per exclusive economic zone.\nBelow I test my function using data from SeaLifeBase to find suitable habitat for the Bottlenose Dolphin. In reality, however, geolocating Bottlenose Dolphin habitat may depend on additional key factors.\n\n# creating a function that takes in depth ranges, temperature ranges, and species name\nsuitability_map_fun = function(shallowest_depth, deepest_depth, min_temp, max_temp, species_name){\n  \n  # code sourced from the \"find suitable locations\" section\nrcl_sst <- matrix(c(-Inf, min_temp, NA,\n                    min_temp, max_temp, 1,\n                 max_temp, Inf, NA), ncol = 3, byrow = TRUE)\nsst_suitable <- classify(average_sst_degC, rcl = rcl_sst)\n\nrcl_depth <- matrix(c(-Inf, -deepest_depth, NA,\n                    -deepest_depth, shallowest_depth, 1,\n                 shallowest_depth, Inf, NA), ncol = 3, byrow = TRUE)\ndepth_suitable <- classify(depth_newres, rcl = rcl_depth)\n\nmult_fun = function(rast1, rast2){\n  rast1 * rast2\n}\ndepth_and_stt_suitable <- lapp(c(depth_suitable, sst_suitable), fun = mult_fun)\n\n  # code sourced from the \"Determine the most suitable EEZ\" section\nwc_regions_simp <- wc_regions |> \n  select(\"rgn\")\nwc_regions_rast <- rasterize(x = wc_regions_simp, y = depth_and_stt_suitable, field = \"rgn\")\nwc_regions_mask <- mask(wc_regions_rast, depth_and_stt_suitable)\n\nsuitable_area_byregion <- zonal(cellSize(wc_regions_mask, unit=\"m\"), wc_regions_mask, fun = \"sum\") |> \n  mutate(area = area / (1000^2)) |> \n  rename(suitable_area_km2 = area)\n\ntotal_area_byregion <- zonal(cellSize(wc_regions_rast, unit=\"m\"), wc_regions_rast, fun = \"sum\") |> \n  mutate(area = area / (1000^2)) |> \n  rename(total_area_km2 = area)\n\npercent_area_df <- inner_join(total_area_byregion, suitable_area_byregion, by = \"rgn\") |> mutate(percent_suitable = (suitable_area_km2/total_area_km2) * 100)\n\n# code sourced from the \"Determine the most suitable EEZ\" section\nregion_stats_join <- merge(wc_regions, percent_area_df)\n\ntmap_mode(\"view\")\n\nlegend_title_area = paste0(\"Suitable Area for the \", species_name, \" Species (km^2)\")\narea_suitable_map <- tm_shape(region_stats_join) +\n  tm_fill(col = \"suitable_area_km2\",\n          title = legend_title_area,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders() +\n  tm_legend(legend.outside = TRUE) +\n  tm_text(\"rgn\", size = 0.3) +\n  tm_basemap(server = \"OpenTopoMap\")\n\nlegend_title_percent = paste0(\"Percent of Region Suitable for the \", species_name, \" Species\")\npercent_suitable_map <- tm_shape(region_stats_join) +\n  tm_fill(col = \"percent_suitable\",\n          title = legend_title_percent,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders() +\n  tm_legend(legend.outside = TRUE) +\n  tm_text(\"rgn\", size = 0.3) +\n  tm_basemap(server = \"OpenTopoMap\")\n\ntmap_arrange(area_suitable_map, percent_suitable_map)\n\n}\n\n# running the function for the bottlenose dolphin\n  # source: https://www.sealifebase.ca/summary/Tursiops-truncatus.html\nsuitability_map_fun(shallowest_depth = 0, deepest_depth = 1316, min_temp = 6.4, max_temp = 28.9, species_name = \"Dolphin\")\n\ntmap mode set to interactive viewing"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "blog & portfolio",
    "section": "",
    "text": "GEOSPATIAL DATA ANALYSIS\n\n\nMAPPING\n\n\nRASTERS\n\n\nSHAPEFILES\n\n\nRECLASSIFYING\n\n\nMASKING\n\n\n\nCleaning and reclassifying geospatial vector and raster data to pinpoint optimal zones.\n\n\n\nVictoria Cutler\n\n\nJul 20, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPYTHON\n\n\nREMOTE SENSING\n\n\nVEGETATIVE HEALTH\n\n\nNDVI\n\n\nDEFORESTATION\n\n\nLAND COVER CHANGE\n\n\nGOOGLE EARTH ENGINE\n\n\nLANDSAT\n\n\n\nUsing both true- and false- colored satellite imagery.\n\n\n\nVictoria Cutler\n\n\nJul 9, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCAL COFI\n\n\nOCEAN ACIDIFICATION\n\n\nMACHINE LEARNING\n\n\nEXTREME GRADIENT BOOSTING\n\n\nR\n\n\n\nA journey through my code to the winning RMSE score.\n\n\n\nVictoria Cutler\n\n\nMar 22, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nETHICS\n\n\nAI\n\n\nOPEN SCIENCE\n\n\n\nHow can we construct AI without unintended consequences?\n\n\n\nVictoria Cutler\n\n\nDec 7, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nROOFTOP SOLAR\n\n\nEQUITY\n\n\nSTATISTICS\n\n\nR\n\n\n\nWho benefits and who doesn’t?\n\n\n\nVictoria Cutler\n\n\nDec 4, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  }
]